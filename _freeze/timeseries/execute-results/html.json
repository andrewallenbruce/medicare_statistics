{
  "hash": "9a511f4396171a477f6c488fb8255e05",
  "result": {
    "markdown": "---\ntitle: \"Time Series Forecasting\"\nauthor: \"Andrew Bruce\"\nformat: \n  html:\n    theme: zephyr\n    toc: true\n    number-sections: false\ndate: last-modified\ncode-fold: true\ncode-overflow: scroll\n---\n\n::: {.cell}\n\n:::\n\n\n\n# Links\n\n[Forecasting: Principles and Practice](https://otexts.com/fpp3/index.html)\n\n# Forecasting Data and Methods\n\nThe appropriate forecasting methods depend largely on what data are available. <br>\n\nIf there are no data available, or if the data available are not relevant to the forecasts, then **qualitative forecasting** methods must be used. These methods are not purely guesswork — there are well-developed structured approaches to obtaining good forecasts without using historical data. These methods are discussed in Chapter 6. <br>\n\n**Quantitative forecasting** can be applied when two conditions are satisfied: <br>\n\n   1. numerical information about the past is available;\n   2. it is reasonable to assume that some aspects of the past patterns will continue into the future.\n\n<br>\n\nThere is a wide range of quantitative forecasting methods, often developed within specific disciplines for specific purposes. Each method has its own properties, accuracies, and costs that must be considered when choosing a specific method. <br>\n\nMost quantitative prediction problems use either time series data (collected at regular intervals over time) or cross-sectional data (collected at a single point in time). In this book we are concerned with forecasting future data, and we concentrate on the time series domain. <br>\n\nAnything that is observed sequentially over time is a time series. In this book, we will only consider time series that are observed at regular intervals of time (e.g., hourly, daily, weekly, monthly, quarterly, annually). Irregularly spaced time series can also occur, but are beyond the scope of this book. <br>\n\nWhen forecasting time series data, the aim is to estimate how the sequence of observations will continue into the future. <br>\n\n# `tsibble` Objects\n\nA time series can be thought of as a list of numbers (the measurements), along with some information about what times those numbers were recorded (the index). This information can be stored as a `tsibble` object in R. <br>\n\nSuppose you have annual observations for the last few years:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_month <- enroll_33 |> \n  dplyr::select(year, dplyr::any_of(tolower(month.name))) |> \n  tidyr::pivot_longer(cols = dplyr::any_of(tolower(month.name)),\n                      names_to = \"month\",\n                      values_to = \"deaths\") |> \n  dplyr::mutate(month = stringr::str_to_title(month),\n                month = factor(month, levels = month.name),\n                date = clock::as_date(clock::year_month_day(year, as.integer(month), 1)),\n                mon = lubridate::month(date, label = TRUE, abbr = TRUE),\n                type = \"Medicare\") |> \n  dplyr::select(type, date, deaths) |> \n  dplyr::mutate(month = tsibble::yearmonth(date),\n                date = NULL) |> \n  tsibble::as_tsibble(index = month)\n\ndeaths_month\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 168 x 3 [1M]\n   type     deaths    month\n   <chr>     <dbl>    <mth>\n 1 Medicare 183291 2008 Jan\n 2 Medicare 182939 2008 Feb\n 3 Medicare 191125 2008 Mar\n 4 Medicare 167865 2008 Apr\n 5 Medicare 162702 2008 May\n 6 Medicare 151849 2008 Jun\n 7 Medicare 152562 2008 Jul\n 8 Medicare 152562 2008 Aug\n 9 Medicare 150384 2008 Sep\n10 Medicare 161946 2008 Oct\n# ℹ 158 more rows\n```\n:::\n:::\n\n<br>\n\nFirst, the `date` column is being converted from text to a monthly time object with `yearmonth()`. We then convert the data frame to a `tsibble` by identifying the index variable using `as_tsibble()`. Note the addition of `[1M]` on the first line indicating this is monthly data. <br>\n\nOther time class functions can be used depending on the frequency of the observations: <br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_qtr <- enroll_33 |> \n  dplyr::select(year, dplyr::any_of(tolower(month.name))) |> \n  tidyr::pivot_longer(cols = dplyr::any_of(tolower(month.name)),\n                      names_to = \"month\",\n                      values_to = \"deaths\") |> \n  dplyr::mutate(month = stringr::str_to_title(month),\n                month = factor(month, levels = month.name),\n                date = clock::as_date(clock::year_month_day(year, as.integer(month), 1)),\n                mon = lubridate::month(date, label = TRUE, abbr = TRUE),\n                type = \"Medicare\") |> \n  dplyr::select(type, date, deaths) |> \n  dplyr::mutate(quarter = tsibble::yearquarter(date),\n                date = NULL) |> \n  dplyr::group_by(quarter, type) |> \n  dplyr::summarise(deaths = sum(deaths), .groups = \"drop\") |> \n  tsibble::as_tsibble(index = quarter)\n\ndeaths_qtr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tsibble: 56 x 3 [1Q]\n   quarter type     deaths\n     <qtr> <chr>     <dbl>\n 1 2008 Q1 Medicare 557355\n 2 2008 Q2 Medicare 482416\n 3 2008 Q3 Medicare 455508\n 4 2008 Q4 Medicare 502936\n 5 2009 Q1 Medicare 520775\n 6 2009 Q2 Medicare 477660\n 7 2009 Q3 Medicare 459395\n 8 2009 Q4 Medicare 506256\n 9 2010 Q1 Medicare 525836\n10 2010 Q2 Medicare 483274\n# ℹ 46 more rows\n```\n:::\n:::\n\n\n<br>\n\n# The Seasonal Period\n\nSome graphics and some models will use the seasonal period of the data. The seasonal period is the number of observations before the seasonal pattern repeats. In most cases, this will be automatically detected using the time index variable. <br>\n\nFor quarterly, monthly and weekly data, there is only one seasonal period — the number of observations within each year. Actually, there are not  \n52 weeks in a year, but `365.25 / 7 = 52.18` on average, allowing for a leap year every fourth year. Approximating seasonal periods to integers can be useful as many seasonal terms in models only support integer seasonal periods. <br>\n\n## Time Series Patterns\n\nMany time series include trend, cycles and seasonality. When choosing a forecasting method, we will first need to identify the time series patterns in the data, and then choose a method that is able to capture the patterns properly. <br>\n\n::: {.callout-note appearance=\"simple\"}\n\n## Trend\n\nA trend exists when there is a long-term increase or decrease in the data. It does not have to be linear. Sometimes we will refer to a trend as “changing direction”, when it might go from an increasing trend to a decreasing trend. \n\n:::\n\n::: {.callout-note appearance=\"simple\"}\n\n## Seasonal\n\nA seasonal pattern occurs when a time series is affected by seasonal factors such as the time of the year or the day of the week. Seasonality is always of a fixed and known period.\n\n:::\n\n::: {.callout-note appearance=\"simple\"}\n\n## Cyclic\n\nA cycle occurs when the data exhibit rises and falls that are not of a fixed frequency. These fluctuations are usually due to economic conditions, and are often related to the “business cycle”. The duration of these fluctuations is usually at least 2 years. <br>\n\nMany people confuse cyclic behaviour with seasonal behaviour, but they are really quite different. If the fluctuations are not of a fixed frequency then they are cyclic; if the frequency is unchanging and associated with some aspect of the calendar, then the pattern is seasonal. In general, the average length of cycles is longer than the length of a seasonal pattern, and the magnitudes of cycles tend to be more variable than the magnitudes of seasonal patterns.\n\n:::\n\n\n<br>\n\n# Time Series Decomposition\n\nTime series data can exhibit a variety of patterns, and it is often helpful to split a time series into several components, each representing an underlying pattern category. <br>\n\nThere are three types of time series patterns: **trend, seasonality and cycles**. When we decompose a time series into components, we usually combine the trend and cycle into a single **trend-cycle** component (often just called the **trend** for simplicity). Thus we can think of a time series as comprising three components: a trend-cycle component, a seasonal component, and a remainder component (containing anything else in the time series). <br>\n\nWhen decomposing a time series, it is sometimes helpful to first transform or adjust the series in order to make the decomposition (and later analysis) as simple as possible. <br>\n\n## Transformations and Adjustments\n\nAdjusting the historical data can often lead to a simpler time series. Here, we deal with four kinds of adjustments: calendar adjustments, population adjustments, inflation adjustments and mathematical transformations. The purpose of these adjustments and transformations is to simplify the patterns in the historical data by removing known sources of variation, or by making the pattern more consistent across the whole data set. Simpler patterns are usually easier to model and lead to more accurate forecasts. <br>\n\n### Calendar adjustments\n\nSome of the variation seen in seasonal data may be due to simple calendar effects. In such cases, it is usually much easier to remove the variation before doing any further analysis. <br>\n\nFor example, if you are studying the total monthly sales in a retail store, there will be variation between the months simply because of the different numbers of trading days in each month, in addition to the seasonal variation across the year. It is easy to remove this variation by computing average sales per trading day in each month, rather than total sales in the month. Then we effectively remove the calendar variation. <br>\n\n### Population adjustments\n\nAny data that are affected by population changes can be adjusted to give per-capita data. That is, consider the data per person (or per thousand people, or per million people) rather than the total. For example, if you are studying the number of hospital beds in a particular region over time, the results are much easier to interpret if you remove the effects of population changes by considering the number of beds per thousand people. Then you can see whether there have been real increases in the number of beds, or whether the increases are due entirely to population increases. It is possible for the total number of beds to increase, but the number of beds per thousand people to decrease. This occurs when the population is increasing faster than the number of hospital beds. For most data that are affected by population changes, it is best to use per-capita data rather than the totals. <br>\n\n### Inflation adjustments\n\nData which are affected by the value of money are best adjusted before modelling. For example, the average cost of a new house will have increased over the last few decades due to inflation. A \\$200,000 house this year is not the same as a \\$200,000 house twenty years ago. For this reason, financial time series are usually adjusted so that all values are stated in dollar values from a particular year. For example, the house price data may be stated in year 2000 dollars. <br>\n\nTo make these adjustments, a price index is used. If $z_t$ denotes the price index and $y_t$ denotes the original house price in year $t$, then $x_t = y_t/z_t ∗ z_2000$ gives the adjusted house price at year 2000 dollar values. Price indexes are often constructed by government agencies. For consumer goods, a common price index is the Consumer Price Index (or CPI). <br>\n\nThis allows us to compare the growth or decline of industries relative to a common price value. For example, looking at aggregate annual “newspaper and book” retail turnover from aus_retail, and adjusting the data for inflation using CPI from global_economy allows us to understand the changes over time. <br>\n\n## Mathematical transformations\n\nIf the data shows variation that increases or decreases with the level of the series, then a transformation can be useful. For example, a logarithmic transformation is often useful. <br>\n\n## Time Series Components\n\n# Monthly Deaths\n\n## Time Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_month |> \n  feasts::autoplot(deaths) + \n  labs(title = \"Medicare Beneficiary Deaths (Monthly)\", \n       y = NULL)\n```\n\n::: {.cell-output-display}\n![](timeseries_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n<br>\n\n## Seasonal Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_month |> \n  feasts::gg_season(deaths, labels = \"both\") + \n  labs(title = \"Medicare Beneficiary Deaths (Monthly)\", \n       y = NULL, x = NULL)\n```\n\n::: {.cell-output-display}\n![](timeseries_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n<br>\n\n## Seasonal Subseries Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_month |> \n  feasts::gg_subseries(deaths) + \n  labs(title = \"Medicare Beneficiary Deaths (Monthly)\", \n       y = NULL)\n```\n\n::: {.cell-output-display}\n![](timeseries_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n<br>\n\n## Lag Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_month |> \n  feasts::gg_lag(deaths, geom = \"point\") + \n  labs(title = \"Medicare Beneficiary Deaths (Monthly)\", y = NULL)\n```\n\n::: {.cell-output-display}\n![](timeseries_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n<br>\n\n## Autocorrelation Plot\n\n### Trend and seasonality in ACF plots\n\nWhen data have a trend, the autocorrelations for small lags tend to be large and positive because observations nearby in time are also nearby in value. So the ACF of a trended time series tends to have positive values that slowly decrease as the lags increase. <br>\n\nWhen data are seasonal, the autocorrelations will be larger for the seasonal lags (at multiples of the seasonal period) than for other lags. <br>\n\nWhen data are both trended and seasonal, you see a combination of these effects. The data shows both trend and seasonality. The slow decrease in the ACF as the lags increase is due to the trend, while the “scalloped” shape is due to the seasonality. <br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_month |>\n  feasts::ACF(deaths, lag_max = 48) |>\n  feasts::autoplot() + \n  labs(title = \"Medicare Beneficiary Deaths (Monthly)\", \n       y = \"ACF (Autocorrelation Function)\")\n```\n\n::: {.cell-output-display}\n![](timeseries_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n<br>\n\n# Quarterly Deaths\n\n## Time Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_qtr |> \n  feasts::autoplot(deaths) + \n  labs(title = \"Medicare Beneficiary Deaths (Quarterly)\", y = NULL)\n```\n\n::: {.cell-output-display}\n![](timeseries_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n<br>\n\n## Seasonal Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_qtr |> \n  feasts::gg_season(deaths, labels = \"both\") + \n  labs(title = \"Medicare Beneficiary Deaths (Quarterly)\", y = NULL)\n```\n\n::: {.cell-output-display}\n![](timeseries_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n<br>\n\n## Seasonal Subseries Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_qtr |> \n  feasts::gg_subseries(deaths) + \n  labs(title = \"Medicare Beneficiary Deaths (Quarterly)\", y = NULL)\n```\n\n::: {.cell-output-display}\n![](timeseries_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n<br>\n\n## Lag Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_qtr |> \n  feasts::gg_lag(deaths, geom = \"point\") + \n  labs(title = \"Medicare Beneficiary Deaths (Quarterly)\", y = NULL)\n```\n\n::: {.cell-output-display}\n![](timeseries_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n<br>\n\n## Autocorrelation Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeaths_qtr |>\n  feasts::ACF(deaths, lag_max = 48) |>\n  feasts::autoplot() + \n  labs(title = \"Medicare Beneficiary Deaths (Quarterly)\", \n       y = \"ACF (Autocorrelation Function)\")\n```\n\n::: {.cell-output-display}\n![](timeseries_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n<br>\n",
    "supporting": [
      "timeseries_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}